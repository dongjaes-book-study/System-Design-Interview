# 5. 안정 해시

일반 hash를 이용해 샤딩하면 노드에 장애가 생겼을 때 거의 모든 데이터를 재배치해야함. ⇒ 안정 해시를 사용하면 k/n개만 재배치

### 안정 해시의 문제

- 균등 분포가 되지 않을 수 있음
  1. 노드에 장애가 생기면 특정 노드가 커버하는 범위만 엄청 넓어질 수 있음(s1에 장애가 생기면 s2가 s1의 모든 부분을 커버하기 때문)
  2. 해시값으로 보면 균등하더라도 실제 데이터는 균등하지 않을 수 있음
- 해결 책
  - virtual node 개념을 사용해서 파티션을 잘개 쪼갬.

# 6. 키-값 저장소 설계

## CAP

근데 분산 시스템에서는 p를 버릴 순 없음. 네트워크 장애가 안 일어날 수 없기 때문. CP or AP 임

해시 링을 사용해서 데이터를 샤딩하고
N개의 서버에 데이터를 보관함.

### Quorum Consensus

N = 사본 개수

W = 쓰기 연산에 대한 정족수, W개의 노드한테 응답을 받아야 쓰기 확정(W개의 노드에 기록한다는 말이 아님. 응답을 W개 받아야 확정이란 말임)

R = 읽기 연산에 대한 정족수, R개의 노드가 동의하는 값을 읽음

W+R > N : 강한 일관성 (보통 N=3. W=2. R=2)

W+R ≤ N : 약한 일관성

최종 일관성 : 약한 일관성 중 하나로 결국은 일관성을 가지게 됨

### 버저닝 : 비일관성 해소 기법

어떤 노드에서 데이터를 읽어서 어떤 값으로 변경했는 지를 vertor clock으로 버저닝 해놓음.

### 단점

1. 충돌 해소 로직이 클라이언트에 들어가서 클라이언트가 복잡해짐
2. vector clock의 수가 굉장히 빨리 늘어남 ⇒ 그래서 삭제해줘야하는데 삭제하면 버저닝을 제대로 못 하는 생김. 근데 아마존의 문서가 그런걸로 문제 일어난 적 없다고 함

### 장애 감지

- gossip protocol
  - 각 노드는 membership list에 멤버ID와 heartbeat counter 쌍의 목록을 기록해놓음
  - 주기적으로 자신의 heartbeat counter를 증가시킴.
  - 각 노드는 무작위로 선정된 노드들에게 주기적으로 자신의 heartbeat counter를 전송함.
  - 이를 받은 노드는 멤버십 리스트를 갱심
  - 어떤 멤버의 값이 일정 시간동안 갱신되지 않으면 장애상태로 간주

### 장애 처리

- 일시적 장애 처리
  - hinted handoff : 임시로 장애노드를 대체한 노드에서 hint를 남겨두고 이를 사용해 노드가 복구되면 처리함
- 영구적 장애 처리
  - 머클트리 사용 : 다른 부분을 빨리 찾을 수 있음

# 7. 유일ID 생성기

## 1. 다중 마스터 복제

k개의 마스터 데이터베이스마다 별도의 ID를 할당하고 ID를 1씩 늘리는게 아니라 k씩 늘릴 수 있음

- 확장성 떨어짐
- ID의 유일성은 보장되지만 시간의 흐름에 맞추어 보기 힘듦

## 2. UUID

중복 UUID가 1개 생길 확률을 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년동안 생성해야 한다.

- 장점 : 빠르고 구현도 쉽고 확장도 쉽다
- 단점 : 128bit로 너무 길다.

## 3. 티켓 서버

ID생성용 서버를 하나 두기

- 중소 규모 애플리케이션에서 적합함
- SPOF

## 4. 트위터 스노플레이크 접근법

- sign : 1비트, 음양 구분 가능
- timestamp : 41비트
- 데이터센터 ID 5비트
- 서버 ID : 5비트
- 일련번호 : 12비트

# 8. URL 단축기

## 1. 해시 함수

근데 해시함수로 하면 너무 길 수 있음.

그러면 앞자리만 쓸 수 있음.
⇒ hash(hash(긴 URL).strcnv(7)).strcnv(7)

## 2. 62진법

# 질문

1. 정족수를 커스터마이징 해 본 경험이 있으신 분 있나요..? 정족수를 사람이 커스터마이징해도 괜찮은 걸 까요?
2. 62진법보다 해쉬함수가 대중적인 이유?
