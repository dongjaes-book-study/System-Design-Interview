질문 1. UUID를 시간순서대로 나열하는 방법이 정말 없나?  
질문 2. 해시 키를 사용하면 보안적인 문제는 없을까? 

# 5장. 안정 해시 설계 

## 해시 키 재배치 문제
n개의 서버에서 서버가 추가되거나 삭제될 시 문제에 봉착한다. 이 문제를 해결하고자 다양한 방법이 제시된다.  
기본적인 해시 재배치는 다음과 같은 방식으로 진행된다.  
```serverIndex = hash(key) % N```  
  - 장점: 단순함  
  - 단점: 기존 존재하던 캐시 값들이 대다수 재정렬된다.

## 안정 해시  
원형의 공간상에서 균등하게 분포시킨 뒤 시계방향으로 만나는 첫번째 서버에 정보를 저장하는 방법이다.
  - 장점: 키 재배치가 일어나지 않는다.
  - 단점: 파티션의 크기를 균등하게 유지하는 것이 불가능하다.  
          균등분포를 달성하기 어렵다.

## 가상 노드
원형의 공간상에서 서버가 갖는 노드가 한 개가 아닌, 2개 이상의 가상 노드를 정의하여 위와 비슷한 방식으로 작동. 서버의 제거, 추가시 일부는 재배치 해야하지만 그 수가 많지 않다.
  - 장점: 안정 해시보다 균등한 크기 유지 가능(100개-10%, 200개-5% 편차)  
  - 단점: 가상 노드를 저장할 추가적인 공간이 필요하다.  

# 6장. 키-값 저장소

## key-value 데이터 형식
  - 키-값 저장소(key-value store)는 비 관계형 데이터베이스다.
  - 고유 식별자(identifier)를 키로 갖는다.
  - 키와 값 사이의 연결관계를 “키-값" 쌍(pair)이라고 한다.
  - 키의 사례는 “last_logged_int_at” 처럼 텍스트 키와 “253DDEC4” 처럼 해시 키가 있다.
  - python의 dictionary형식

## 문제의 이해 및 설계 범위 확정
책에서는 다음과 같은 기준을 잡았다.
  - 키-값 쌍의 크기는 10KB 이하
  - 큰 데이터 저장 가능
  - 높은 가용성(장애 시에도 빠르게 응답)
  - 높은 규모 확장성(트래픽 양에 따라 자동 서버 증설 및 삭제 가능)
  - 데이터 일관성 수준 조절 가능
  - 응답 지연시간(latency) 최소

## 단일 저장소
한 대의 서버로 저장소를 구현하는 것이다. 
  장점: 직관적, 구현 난이도 쉬움
  단점: 확장의 한계성

## 분산 저장소
분산 해시 테이블이라고도 하며 이 시스템을 설계할 시 cap정리를 이해해야한다.



# 7장. 분산 시스템을 위한 유일 ID 생성기 설계
mysql과 같은 대다수의 데이터베이스 시스템은 auto_increment속성과 기능을 제공한다. 하지만 서버가 여러대이고, 지연시간을 낮추는 요구사항에 대해서는 해결할 수 없다.  
## 문제 이해 및 설계 범위 확정
여느때와 같이 면접관에게 설계에 대한 명확한 범위를 요구하자.  
책에서는 다음과 같은 요구사항을 정의했다.  
  - ID는 유일하고 정렬가능해야 한다
  - ID는 64비트로 표현될 수 있는 값이어야 한다
  - 시간 순서에 따라 나중에 만든 값이 더 커야 한다
  - 숫자로만 구성되야 한다
  - 초당 10,000 ID 를 생성할 수 있어야 한다

## 다중 마스터 복제
앞서 살펴본 auto_increment 기능을 활용하는 것이다. 서버에 따라 k만큼씩 증가하는 방법을 사용한다.
  - 장점: 규모의 확장성 문제를 조금 해결 가능  
        테이터베이스의 크기를 늘리면 초당 생성가능한 ID수도 늘릴 수 있다.  
  - 단점: 여러 데이터 센터에 걸쳐 규모를 늘리기는 어렵다.  
          시간에 따른 증가를 보장할 수 없다.  
          서버의 추가/삭제 시 동작이 어렵다.  

## UUID
UUID는 128비트짜리의 수이다. 
- 장점: 만드는 것이 단순하면 동기화 이슈가 없다.  
        규모의 확장이 쉽다.
- 단점: 요구사항 64비트보다 크다.  
        ID를 시간 순서대로 정렬할 수 없다.  
        숫자가 아닌 값이 함께 포함된다.  

## 티켓 서버
다중 마스터 복제와 유사하게 DB의 auto increment를 활용하지만 티켓 서버를 중앙 집중형으로 하나만 사용하는 방법

  - 장점: 유일성이 보장되는 오직 숫자로만 구성되는 ID를 쉽게 만들 수 있다.     
    구현하기 쉽고, 중소 규모 애플리케이션에도 적합하다.

  - 단점: 티켓 서버가 SPOF가 된다  
    이를 해결하려고 여러개의 타겟서버를 두면 데이터 동기화 이슈가 생긴다

## 트위터 스노플레이크 접근법
각 비트의 쓰임새는 다음과 같다.
  - 1비트 - 사인비트, 쓰임새가 현재는 없지만 나중을 위해 유보. 음수 양수를 구분할 수 있을 것이다
  - 41비트 - 타임스탬프, 기원 시각 이후 millisecond 단위로 값을 표현한다. 총 41비트 이므로 약 69년을 cover할 수 있고 기원 시각 이후 69년이 지나면 migration 또는 기원시각 조정이 필요하다
  - 5비트 - 데이터 센터 ID로 총 32개의 데이터 센터를 지원할 수 있다
  - 5비트 - 서버 ID, 한 데이터 센터당 32개의 서버를 지원할 수 있다.
  - 12비트 - 일련번호 - 각 서버에서는 ID를 생성할 때마다 일련번호를 1만큼 증가시키고, 이 값은 1밀리초 기준으로 0으로 초기화 시킨다 (그러면 타임스탬프가 바뀌게 되어 구분할 수 있다)

# 8장. URL 단축기 설계

## 개략적 추정
- 쓰기 연산: 매일 1억개의 단축 URL 생성
- 초당 쓰기 연산: 1억/24/3600 = 1160, 읽기는 11600으로 가정
- URL 단축 서비스 10년간 운영 가정: 1억 * 365 * 10 = 3650억 개의 레코드를 보관해야 함
- 축약 전 URL 평균 길이 100 byte
- 즉, 10년 동안 필요한 저장 용량은 3650 * 100 = 36.5TB

## API 엔드포인트
URL 단축기는 기본적으로 2개의 엔드포인트를 필요로 함.

- URL 단축용 엔드포인트  
  : 새 단축 URL을 생성하고자 할 때, 단축할 URL을 인자로 넣어 POST 요청
- URL 리다이렉션 엔드포인트  
  : 단축 URL에 대해 HTTP 요청이 오면 원래의 URL로 보내주기 위해 리다이렉션 URL 반환

## URL redirection
사용자가 단축 url을 우리 서버에 요청하면 원래 url을 반환하는 과정으로 수행된다. 이때 301응답과 302응답이 있다.  

**[301 Moved Permanently](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/301)**

- 해당 url이 HTTP처리 책임이 영구적으로 location 헤더ㅔ 반환된 url로 이전되었다는 응답.  
- 검색엔진 최적화의 관점에서는 '원 콘텐츠가 새로운 URL로 옮겨졌다'(the link-juice is sent to the new URL)고 한다.

- 영구적으로 이전 되었음으로 브라우저에서는 이 응답을 캐시한다. 즉, 단축 URL로의 request를 받았을 때 캐시된 데이터가 있다면, 브라우저는 원래 URL로 요청을 보내게 된다.
- 단축 URL 서버 부하를 줄이고 싶은 경우, 301을 사용하는 것이 좋을 수 있다.

### **[302 Found](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/302)**

- 일시적으로 이전 됬음을 나타내므로 캐시되지 않는다. 즉, 단축 URL로의 request는 언제나 단축 URL 서버로 보내진 뒤 원래 URL로 redirection 될 것이다.
- 트래픽 분석 등 단축 URL 서버에서 모든 요청을 받아보는 것이 유의미한 경우, 302를 사용하는 것이 좋을 수 있다.

## URL 단축
- URL redirection을 구현하는 직관적인 방법은 해시 테이블을 사용하는 것이다.  
- hash값에 따른 url의 개수는 다음과 같다.  
- 문자의 개수 = 62  
  따라서 62^1 = 62, 62^8 = 218,340,105,584,896 즉 이미 7만 되어도 3.5조개로 충분하다.  

## 해시 후 충돌 해소
- 해시값을 구하는 방법으로 CRC32, MD5, SHA-1과 같은 해시 함수를 이용하면 된다.  
  하지만 결과값도 7자리 문자보다 긺.
- 7자리에서 자르고 나머지를 해시결과에 합하는 방법 사용
- 하지만 이 방법은 데이터베이스에 여러번 질의해야하므로 오버헤드가 큼

## base-62 변환
- 따로 해시 함수를 사용하지 않고, 62진법을 통해 원본 url을 62진법으로 변환시키는 것.
- 단점: 앞에서와 같이 유일성 보장 ID 생성기가 따로 필요함.