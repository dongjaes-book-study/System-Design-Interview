# 질문
1. 알림 서비스 하나를 제대로 보내는 것에 많은 요소들이 필요한데(메시지 큐, 메모리, 데이터베이스), 더 가볍게 만들면 어떤식으로 만들 수 있을까요? (비슷한 기능을 하지만 가성비 있게, 확장성도 고려하면서)

2. 채팅 앱에서 비디오나 미디어와 같은 부분들은 어떻게 보내는 것이 현명할까요?

# 9장 웹 크롤러 설계

웹 크롤러의 기본 알고리즘

1. URL 집합이 입력으로 주어지면, 해당 URL들이 가리키는 모든 웹 페이지 다운로드
2. 다운 받은 웹 페이지에서 URL 추출
3. 추출된 URL들을 다운로드할 URL 목록에 추가하고 위 과정을 처음부터 반복

이 과정에서 수집 대상 서버로 짧은 시간 안에 너무 너무 많은 요청을 보내는 무례한 일을 저지르지 않기 위해서, 한 번에 한 페이지만 요청해야됨

즉 특정 도메인에 한번에 많은 트래픽이 쏟아지지 않도록 만들어야됨

이를 위해서 큐 라우터와 큐 선택기를 둬서 처리

## 큐 라우터
큐 라우터는 같은 호스트에 속한 URL은 언제나 같은 큐로 가도록 보장

## 큐 선택기
큐 선택기는 큐들을 순회하면서 큐에서 URL을 꺼내서 해당 큐에서 나온 URL을 다운로드하도록 지정된 스레드에게 전달


## 순위 결정 장치
어떤 URL을 먼저 크롤링해야할 지 그 순위를 정해줌 (트래픽 양, 갱신 빈도 등을 통해)

## HTML 다운로더
해당 HTML 다운로더를 사용하기 전에 로봇 제외 프로토콜(Robots.txt)를 통해 크롤러가 수집해도 되는 페이지 목록을 확인한다.

해당 로봇 제외 프로토콜에 대해서 지속적으로 다운로드 받을 수는 없으니깐 캐싱해서 저장함

## 성능 올리기

### 분산 크롤링
다수의 서버에 URL을 배분해서 일을 진행하게 함

### 도메인 이름 변환 결과 캐시
도메인 이름 변환기(DNS Resolver)는 크롤러 성능의 병목 중 하나인데, DNS 요청 처리를 보내고 기다리는 동안은 다른 작업을 진행할 수 없기 때문에

그렇기 떄문에 DNS 결과와 IP 매핑을 캐시에 보관해 놓고, 크론잡 등을 주기적으로 돌려서 동기화

### 지역성
지역적으로 가까운 서버에서 해당 웹페이지의 크롤링 진행

### 짧은 타임아웃
특정 웹 페이지는 네트워크 상황에 따라 다운로드 속도가 느릴 수 있는데 이에 대해서 타임아웃 시간을 어느정도로 잡고 진행할 것인지 ㄱ

## 문제 있는 콘텐츠 감지 및 회피
### 거미 덫
클로러를 무한 루프에 빠뜨리도록 설계한 웹 페에지, 무한히 깊은 디렉터리 구조를 포함하는 링크를 넣어서 만듦

### 데이터 노이즈
걍 쓸모 없는 정보를 가진 페이지를 크롤리할 때도 있음, 제외하셈

# 10장 알림 시스템 설계

## 알림 지형별 지원 방안

보통 구조가

알림 제공자 -> 제 3자 서비스(APNS, FCM, SMS 서비스, 이메일 서비스) -> 단말


여기에서 다양한 서비스가 존재한다고 가정(MSA 구조와 같은)
알림 시스템이 하나라면 SPOF, 데이터베이스, 캐시 등이 없어서 규모를 개별적으로 늘릴 방법이 없음, 성능 병목 등에 문제가 발생


데이터베이스, 캐시를 분리 후 알림 서버를 증대하고 푸시 알림 큐와 작업서버를 각 대행자 앞에 둬서 날아온 패킷을 푸시 알림 큐에 넣고 작업 서버에서 처리할 수 있도록 구성

## 각 컴포넌트 설명
메시지 큐: 시스템 컴포넌트 간 의존성을 제거하기 위해 사용, 다량의 알림이 전송되어야 하는 경우를 대비한 버퍼 역할도 수행
작업 서버: 메시지 큐에서 전송한 알림을 꺼내서 제 3자 서비스로 전달하는 역할

## 안정성

알림 전송 시스템의 가장 중요한 요구사항 가운데 하나는 어떤 상황에서도 알림이 소실되면 안되는거임

그렇기 대문에 해당 알림 재시도 매커니즘을 만들어야됨
알림 재시도 메커니즘을 만드는 방식 중 하나는 알림 로그를 데이터베이스에 저장하는 것임

-> 중복으로 알림이 전송될 경우도 막아줌, 하지만 완전히 막아주는 건 아님

## 재사용성
알림 템플릿을 만들고, 변하는 정보만 변수로 빼서 처리

## 알림 설정
특정 테이블에 설정 값을 통해서 사용자가 알림 기능을 켜놨는 지 아닌지를 판단

## 전송률 제한
한 사용자가 받을 수 있는 알림의 빈도를 제한, 사용자가 알림 기능을 아예 꺼 버릴 수 있기 때문에

모니터링 및 추적 시스템, 큐에 대해서 이벤트가 잘 처리되고 있는 지 확인해야되기 때문에 필요하고 추적 시스템은 결론적으로 해당 알림을 통한 비즈니스 적 효과가 있었는 지 확인하기 위해서 필요

# 11장 뉴스 피드 시스템 설계

책에서 소개하는 설계안은 피드 발생과 뉴스 피드 생성의 두가지 부분으로 나뉘어져 있음

## 피드 발생
사용자가 스토리를 포시팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다. 새 포스팅은 친구의 뉴스 피드에도 전송된다.

## 뉴스 피드 생성
지면 관계상 뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정

포스트 저장 서비스랑 포스팅 전송 서비스를 둘 다 둠

그래서 한 사람이 포스트에 대해서 업로드하면 데이터베이스 및 캐시에 올리고, 해당 새 포스팅을 친구의 뉴스 피드에 푸시함 -> 쓰기 시점 팬아웃


## 포스팅 전송(팬아웃)
포스팅 전송, 즉 팬아웃은 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정


두 가지 모델이 존재, 쓰기 시점에 팬아웃 모델(푸시 모델) 다른 하나는 읽기 시점에 팬아웃(풀 모델)

### 쓰기 시점 팬아웃 모델
장점

1. 뉴스 피드가 실시간 갱신, 친구 목록에 있는 사용자에게 즉시 전송
2. 보내는 시점에 뉴스 피드가 갱신되므로, 뉴스 피드를 읽는 데 드는 시간이 짧아짐

단점

1. 친구가 많은 경우, 그 목록을 가져오고 목록에 있는 친구드레게 뉴스 피드를 갱신하는 데 오랜 시간이 걸릴 수 있음, 핫키(hotkey)
2. 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 캠퓨팅 자원 낭비

### 읽기 시점 팬아웃 모델
장점

1. 비확성화, 서비스에 거의 로그인하지 않는 사용자의 경우에는 이 모델이 유리
2. 데이터를 친구 각각에 푸시하는 작업이 필요 없으므로, 핫키 문제도 생기지 않음

단점

1. 뉴스 피드를 읽는 데 많은 시간이 소요

### 결론

두 가지 방법을 결합해서 사용, 뉴스 피드를 빠르게가져올 수 있도록 하는 것이 아주 중요하므로 대부분의 사용자에 대해서는 푸시 모델을 사용

하지만 팔로어가 아주 많은 사용자의 경우에는 풀 모델을 사용하여 시스템 과부하 방지

아울러 한정 해시를 통해 요청과 데이터를 보다 고르게 분산하여 핫키 문제를 줄여볼 것임

사용자가 뉴스 피드를 보려고 요청을 날렸을 때를 가정


1. 친구 관계에 대해서 관계형 데이터베이스를 통해서 어떤 지 확인함(내 피드를 받고 싶어하는 지 아닌지와 같은거)
2. 친구 관계를 바탕으로 포스팅 캐시를 봄, 어떤 정보를 가지고 있는 지
3. 해당 정보를 바탕으로 뉴스 피드에 사용자 캐시와 포스팅 캐시에서 가져온 정보를 기반으로 뉴스 피드를 만듦
4. 사용자에게 전달하면 끝

# 12장 채팅 시스템 설계

최대 100명까지 참여 가능하고 응답 지연이 낮은 일대일 채팅 가능, 단양한 단발 지원, 사용자의 접속 상태 표시 가능, 푸시 알림을 이용한 채팅 서비스 설계

HTTP 프로토콜을 사용하는데, keep-alive 헤더를 사용함.
클라이언트와 서버 사이의 연결을 끊지 않고 계속 유지가 가능하기 때문에 TCP 접속 과정에서 발생하는 헨드셰이크 횟수를 줄일 수 있음

HTTP는 클라이언트 중심적으로 동작하는 프로토콜이라, 서버가 연결을 만드는 것처럼 동작할 수 있도록 하기 위해서 폴링, 롱 폴링, 웹소켓 등이 만들어졌음

## 폴링
특정 간격동안 메시지가 있는냐고 물어보는 방법, 폴링 비용은 폴링을 자주하면 할수록 올라감
## 롱 폴링
클라이언트가 새 메시지가 반환되거나 타임아웃 될 때까지 연결을 유지, 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작

### 약점

메시지를 보내는 클라언트와 수신하는 클라이언트가 같은 채팅 서버에 접속하게 되지 않을 수 있음
로드밸런싱을 위해 라운드 로빈 알고리즘을 사용하는 경우, 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와 롱 폴링 연결을 가지고 있지 않은 서버일 수 있음

서버 입장에서는 클라이언트가 연결을 해제했는 지 아닌지 알 좋은 방법이 없음

여전히 비효율적 메시지를 많이 받지 않는 클라이언트도 타임아웃이 일어날 때 마다 주기적으로 서버에 다시 접속할 것임

## 웹소켓
웹소켓 연결은 클라이언트가 시작, 한번 맺어진 연결은 항구적이며 양방향임

이 항구적인 연결이 만들어지고 나면 서버는 클라이언트에게 비동기적으로 메시지를 전송할 수 있음

80, 443처럼 HTTP 혹은 HTTPS 프로토콜이 사용하는 기본 포트 번호를 그대로 쓰기 때문에, 방화벽이 있는 환경에서도 잘 동작

## 데이터
1. 사용자 프로파일, 설정, 친구 목록과 같은 일반적인 데이터 (관계형 데이터 보관)
2. 채팅 시스템에 고유한 데이터, 채팅 이력

빈번하게 상용되는 것은 최근에 주고받은 메시지, 특정 메시지로 점프하거나 하여 무작위적인 데이터 접근도 가능하도록 해야됨

키-값 저장소를 추천, 그 이유는 다음과 같음

값들 중에 message_id를 만드는 기법은 자세히 논의할 만한 가치가 있음
1. 해당 ID는 공유해야됨
2. ID는 정렬 가능해야 하며, 시간 순서와 일치해야됨

해결 방안

1. auto_increment
2. 스노플레이크
3. 지역적 순서 번호 생성기(같은 그룹 안에서만 ID의 유일성을 보증하면 됨)

## 채팅 처리
사용자마다 큐(메시지 수신함)를 두고 여러 서버에서 해당 큐로 입력할 수 있도록 하기

## 접속 장애

연결이 끊어지는 경우는 자주 있음 이때 연결에 대해 끊어졌다고 표시하면 사용성이 안좋음
박동 이벤트를 보내고, 몇 초 이내로 대답이 안오면 연결이 끊어졌다고 판단


## 상태 정보의 전송
상태 정보 서버를 구독 및 발행의 느낌으로 만들어서 사용, 특정 그룹에 대해서 하나의 이벤트 큐를 만들어서 처리하는 거임

