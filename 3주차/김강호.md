# 9장 웹크롤러설계

### 웹 크롤러 이용 사례
- 검색 엔진 인덱싱
- 웹 아카이빙
- 웹 마이닝
- 웹 모니터링

### 웹 크롤러 작업 흐름
1. URL 큐에 시작 URL 추가
2. URL 큐에서 URL 가져오기
3. URL 접속하여 웹 페이지 내용 다운로드
4. 웹 페이지 내용 파싱하여 올바른 형식을 갖춘 페이지인지 검증
5. 중복 컨텐츠 확인
   - 이미 저장소에 있는 콘텐츠인 경우 return
   - 저장소에 없는 콘텐츠인 경우 저장소에 저장 후 URL 추출기로 전달


### BFS vs DFS
- 웹 크롤러의 경우 보통 BFS 사용


# 10장알림시스템설계

### 알림 시스템 설계
1. API를 호출하여 알림 서버로 알림을 보낸다.
2. 알림 서버는 사용자 정보, 단말 토큰, 알림 설정 같은 메타데이터를 캐시나 DB에서 가져온다
3. 알림 서버는 전송할 알림에 맞는 이벤트를 만들어 해당 이벤트를 위한 큐에 넣는다. ex) iOS 푸시 알림 이벤트는 iOS 푸시 알림 큐에 삽입
4. 작업 서버는 메시지 큐에서 알림 이벤트를 꺼낸다.
5. 작업 서버는 알림을 제3자 서비스로 보낸다. (APNS, Firebase, SNS, Email 서비스 등)
6. 제3자 서비스는 알림을 받아서 사용자에게 전달한다.

### 상세 설계

#### 데이터 손실 방지
- 알림 전송 데이터는 어떠한 상황에서도 소실되면 안된다.
- 알림이 지연되거나 순서가 틀려져도 괜찮지만 소실되면 안된다.
- 이를 위해 알림 데이터를 DB에 보관하고 재시도 메커니즘을 구현한다(Message Queue 활용)

#### 알림 중복 전송 방지
- 알림 중복 전송을 방지하기 위해 노력해야 하지만 100% 방지하는 것은 불가능하다.


### 추가 컴포넌트 및 고려사항
- 알림 템플릿
- 알림 설정
- 전송률 제한
- 재시도 방법
- 푸시 알림과 보안
- 큐 모니터링
- 이벤트 추적


# 11장뉴스피드시스템설계

### 피드 발행 흐름 상세 설계

#### 웹 서버
- 클라이언트와 통신할 뿐 아니라 인증이나 처리율 제한 등의 기능을 수행함
- 올바른 인증 토큰을 Authorization 헤더에 넣고 API를 호출하는 사용자만 포스팅 할 수 있어야 한다.
- 유해한 콘텐츠가 자주 올라오는 것을 방지하기 위해 한 사용자가 올릴 수 있는 게시물의 수를 제한한다.

#### 포스팅 전송 서비스
- 쓰기 시점에 팬아웃하는 모델 : 새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신한다.
  - 장점
    - 뉴스 피드가 실시간으로 갱신되며 친구 목록에 있는 사용자에게 즉시 전송된다.
    - 새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신되므로 뉴스 피드를 읽는 데 드는 시간이 짧아진다.
  - 단점
    - 친구가 많은 사용자의 경우 친구 목록을 가져오고 그 목록에 있는 사용자 모두의 뉴스 피드를 갱신하는 데 많은 시간이소요될 수 있다. 핫키 문제
    - 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신해야 하므로 컴퓨팅 자원 낭비
- 읽기 시점에 팬아웃하는 모델 : 피드를 읽어야 하는 시점에 뉴스 피드를 갱신한다. 따라서 요청 기반 모델이다. 사용자가 본인 홈페이지나 타임라인을 로딩하는 시점에 새로운 포스트를 가져오게 된다.
  - 장점
    - 비활성화된 사용자, 또는 서비스에 거의 로그인하지 않는 사용자의 경우에는 이 모델이 유리하다. 로그인하기까지는 어떤 컴퓨팅 자원도 소모하지 않는다.
    - 데이터를 친구 각각에 푸시하는 작업이 필요 없으므로 핫키 문제도 생기지 않는다.
  - 단점
    - 뉴스 피드를 읽는데 많은 시간이 걸릴 수 있다.

### 피드 발행 흐름 상세 설계
1. DB에서 친구 ID 목록을 가져온다.
2. 사용자 정보 캐시에서 친구들을 가져오고 일부를 필터링한다.
3. 친구 목록과 새 스토리의 포스팅 ID를 메시지 큐에 넣는다.
4. 팬아웃 작업 서버가 메시지 큐에서 데이터를 꺼내어 뉴스 피드 데이터를 뉴스 피드 캐시에 넣는다.


### 피드 읽기 흐름 상세 설계
1. 사용자가 피드를 요청한다.
2. 로드밸런서가 요청을 웹 서버 가운데 하나로 보낸다.
3. 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출한다.
4. 뉴스 피드 서비스는 뉴스 피드 캐시에서 포스팅 ID 목록을 가져온다
5. 뉴스 피드에 표시할 사용자 이름, 사용자 사진, 포스팅 콘텐츠, 이미지 등을 사용자 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드를 만든다.
6. 생성된 뉴스 피드를 JSON 형태로 client에게 보낸다.



# 12장채팅시스템설계

### 폴링
- 클라이언트가 주기적으로 서버에게 새 메시지가 있느냐고 물어보는 방법]
- 폴링 비용은 자주 사용하면 할수록 높아지며 답해줄 메시지가 없는 경우에는 서버 자원이 불필요하게 낭비되는 문제가 존재

### 롱 폴링
- 폴링의 여러 가지 비효율적인 문제를 개선하기 위해 나온 기법
- 클라이언트는 새 메시지가 반환되거나 타임아웃 될 떄까지 연결을 유지한다.
- 클라이언트는 새 메시지를 받으면 기존 연결을 종료하고 서버에 새로운 요청을 보내어 모든 절차를 다시 시작한다.

#### 롱 폴링 단점
- 메시지를 받은 서버는 해당 메시지를 수신할 클라이언트와의 롱 폴링 연결을 가지고 있지 않은 서버일 수 있다.

### 웹소켓
- 웹소켓은 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
- 웹소켓은 HTTP와 다르게 서버와 클라이언트 간에 양방향 통신이 가능하다.
- 웹소켓은 메시지를 보내거나 받을 때 동일한 프로토콜을 사용할 수 있어 설계뿐 아니라 구현도 비교적 단순하다

#### 저장소
- NoSQL 저장소 사용


### 접속 상태 표시
#### 사용자 로그인
- 온라인, 오프라인, 자리비움 등의 상태를 표시할 수 있다.
- 클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태를 업데이트 해 접속 중인 것으로 표시

#### 로그아웃
- 클라이언트가 로그아웃하면 접속상태 서버는 해당 사용자의 상태를 오프라인으로 변경

#### 접속 장애
- 박동 이벤트를 사용하여 접속상태를 서버로 보내도록 한다
- 
