질문1. 목표 가용성에 따라 비용은 어느정도의 비율로 증가할까?  
질문2. 처리율 제한 구현에서 Layer7에서가 아닌 lower한 계층에서 구현하면 성능이 더 좋을까?

# 1장. 사용자 수에 따른 규모 확장성

## 단일 서버
  - 웹 앱, 데이터베이스, 캐시 등을 서버 하나에서 전부 실행
  - 사용자가 적을 때 사용
  - 간단하게 구성가능
## 데이터베이스
  - 단일 서버의 부하를 줄이기 위해 데이터베이스용 서버 등장
  - 따라서 구성은  
    가. 웹/모바일 트래픽 처리용도  
    나. 데이터베이스 용도
  - 이때 데이터베이스는 크게 두가지로 구현 가능  
    가. RDBMS  
    나. NoSQL
## 로드밸런서
  - 트래픽 처리용도의 서버에 과부하가 걸릴 수 있기 때문에 등장
  - 보안을 위해 `Public IP`로 로드밸런서에 접근 -> `Private IP`로 서버 간 통신
## 캐시
  - 값비싸고 자주 참조되는 데이터를 빨리 가져오기 위해 등장
  - 캐시 사용 따른 고려사항  
    가. what: 어떤 데이터를 캐시에 둘 것인가  
    나. expire: 데이터를 언제 만료할 것인가 -> consistency문제 -> [scaling memcache at facebook](https://www.usenix.org/system/files/conference/nsdi13/nsdi13-final170_update.pdf)  
    다. how: 장애를 어떻게 대처할 것인가  
    라. eviction: 캐시 방출 정책 등  
## CDN
  - 콘텐츠 전송 네트워크는 지리적 한계에 따른 지연을 극복하고자 등장
  - 서버를 분산해 image, video, CSS, Javascript 파일등을 캐시할 수 있음


# 2장. 개략적인 규모 추정

## 2의 제곱수
|2의 x제곱|근사치|이름|축약형|
|---|---|---|---|
|10|1천|킬로바이트|KB|
|20|100만|메가바이트|MB|
|30|10억|기가바이트|GB|
|40|1조|테라바이트|TB|
|50|1000조|페타바이트|PB|

## 가용성에 관한 수치
|가용률|하루당 장애시간|연간 장애시간|
|---|---|---|
|99%|14.4분|3.65일|
|99.9%|1.44분|8.77시간|
|99.99%|8.64초|52.6분|
|99.999%|864밀리초|5.26분|

## 팁
  - 규모추정과 관련해서 질의를 받는다면 다음과 같은 사항을 고려하자
  - 근사치를 이용한 계산 ex) 9997 / 9.8 을 계산하지 말고 10000/10으로 계산하자
  - 가정들을 다 기록하자
  - 숫자에 단위를 붙여라
  - QPS, 저장소 요구량, 캐시 요구량, 서버 수 등의 문제가 자주 출제된다.


# 3장. 시스템 설계 면접 공략법

## 시스템 설계 면접 접근의 4단계
### 1. 문제 이해 및 설계 범위 확정
  - 정답은 없다. 천천히 생각하고, 정리한 뒤 이야기하지
  - 제안된 설계 구조에서 필요한 사항들과 요구 조건들을 생각하며 확정하자  
    ex) 웹과 앱 중에서 어떤 플랫폼을 이용해야하나요?

### 2. 개략적인 설계안 제시 및 동의 구하기
  - 설계안의 level을 제시하고 동의를 구하자  
    ex) API endpoint나 UML을 구현해야하나요?
  - 화이트보드나 종이에 핵심적인 components를 그리자  
    ex) 웹서버, 데이터 저장소, 캐시, CDN 등

### 3. 상세 설계
  - 달성 목표를 확정하고, 기능 범위 확인
  - 앞서 구현한 청사진에 대한 면접관의 의견 청취

### 4. 마무리
  - 설계한 시스템에 대해 개선 가능한 부분을 찾아내, 제안하자
  - 오류, 에러 상황을 가정하고 스토리텔링을 가져가보기도 하자

## 시간 배분
이러한 시스템을 설게하는 과정에서 주어진 시간을 다음과 같이 배분하자.  
- 1단계 - 5분 ± 5분  
- 2단계 - 10분 ± 5분  
- 3단계 - 20분 ± 5분  
- 4단계 - 5분 ± 1분


# 4장. 처리율 제한 장치의 설계

## 문제이해 및 설계 범위 확정
  - 처리율 제한 기능의 위치 (서버-클라이언트)  
  - 형태 (알고리즘)
  - 규모 (한도량)
  - 독립성 (앱 내부 or 별도의 기능)

## 설계안 제시 및 동의 구하기
  이 단계에서는 처리율 제한에 대해 대략적인 구현 방식을 고민하면 된다.  
  - 처리율 제한의 이유  
    가. DoS 공격 대비 -> 비용절감 효과  
    나. 서버 비용 절감, 과부하 방지

  ### 제한 알고리즘
    - 토큰 버킷 알고리즘  
    : 토큰을 생성, 관리하는 버킷을 구현해, 버킷 사이즈만큼 요청을 받는 방식

      장점: 구현 쉬움, 메모리 적게 사용, 트래픽 관리 용이  
      단점: 버킷 크기와 토큰 공급률에 대한 튜닝의 어려움

    - 누출 버킷 알고리즘
    : 토큰과 비슷하지만 FIFO의 큐를 구현해 요청을 받는 방식

      장점: 고정된 처리율에 의해 안정적 출력이 가능하다.
      단점: 짧은 시간에 몰리는 경우, 최신 요청들이 버려지게 된다

    - 고정 윈도 알고리즘
    : 타임라인을 고정된 window로 나누고, 각 윈도우마다 counter를 붙인다.  

      장점: 구현과 이해가 쉽다. 특정 트래픽 신호에 대한 처리가 적합하다
      단점: 윈도우 사이즈와 별개로, 2배수까지 처리해야하는 경우가 생길 수 있다.

    - 이동 윈도 로깅 알고리즘
    : 요청에 대한 time stamp를 추적하고, 로그 크기에 따라 처리한다

      장점: 고정 윈도우와 다르게 로그 사이즈로 한정이 가능하다.
      단점: 거부 요청의 스탬프에 의해 메모리가 낭비된다.  

    - 이동 윈도 카운터 알고리즘
    : 현재 시간대와 이전 시간대의 요청을 갖고 겹치는 값을 이용한다

      장점: 짧은 시간에 몰리는 트래픽에도 잘 대처할 수 있다, 메모리 효율이 좋다.
      단점: 균등 분포를 가정하기에, 다소 안정적이지 않을 수 있다.  

    